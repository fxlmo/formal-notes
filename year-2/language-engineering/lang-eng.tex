%%=====================================================================================
%%
%%       Filename:  lang-eng.tex
%%
%%    Description:  formal notes for lang-eng
%%
%%        Version:  1.0
%%        Created:  14/10/19
%%       Revision:  none
%%
%%         Author:  Josh Felmeden (), nk18044@bristol.ac.uk
%%   Organization:  
%%      Copyright:  Copyright (c) 2019, Josh Felmeden
%%
%%          Notes:  
%%
%%=====================================================================================

% Preamble {{{
\documentclass[11pt,a4paper,titlepage,dvipsnames,cmyk]{scrartcl}
\usepackage[english]{babel}
\typearea{12}
% }}}

% Set indentation and line skip for paragraph {{{
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}
\usepackage[margin=2cm]{geometry}
\addtolength{\textheight}{-1in}
\setlength{\headsep}{.5in}
% }}}

\usepackage{hhline} 
\usepackage{mathtools} 
\usepackage[T1]{fontenc}

% Headers setup {{{
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Language Engineering - A nice set of notes}
\rhead{Josh Felmeden}
\usepackage{hyperref} 
% }}}

% Listings {{{
\usepackage[]{listings,xcolor} 
\lstset
{
    breaklines=true,
    tabsize=3,
    showstringspaces=false
}

\definecolor{lstgrey}{rgb}{0.05,0.05,0.05}
\usepackage{listings}
\makeatletter
\lstset{language=[Visual]Basic,
    backgroundcolor=\color{lstgrey},
    frame=single,
    xleftmargin=0.7cm,
    frame=tlbr, framesep=0.2cm, framerule=0pt,
    basicstyle=\lst@ifdisplaystyle\color{white}\footnotesize\ttfamily\else\color{black}\footnotesize\ttfamily\fi,
    captionpos=b,
    tabsize=2,
    keywordstyle=\color{Magenta}\bfseries,
    identifierstyle=\color{Cyan},
    stringstyle=\color{Yellow},
    commentstyle=\color{Gray}\itshape
}
\makeatother
\renewcommand{\familydefault}{\sfdefault}
% }}}


% Other packages {{{
\usepackage{needspace}
\usepackage{tcolorbox}
\usepackage{soul}
\usepackage{babel,dejavu,helvet} 
\usepackage{amsmath} 
\usepackage{booktabs} 
\usepackage{tcolorbox} 
\usepackage[symbol]{footmisc} 
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\renewcommand{\familydefault}{\sfdefault}
\newcommand\pfun{\mathrel{\ooalign{\hfil$\mapstochar\mkern5mu$\hfil\cr$\to$\cr}}}
% }}}

% Title {{{
\title{Language Engineering - A nice set of notes}
\author{Josh Felmeden}
% }}}

\begin{document}

\maketitle
\tableofcontents

\newpage

\section{Introduction to Semantics}%
\label{sec:intro-semantics}

Semantics are really complex and they actually exist in the real world as
problems that can arise when the semantics are unclear. In the example of
the Derek Bentley case, Bentley tells Chris (who is holding a gun, and a
policeman standing in front of him to `let him have it!'. Here, it
appears that he could be talking about the gun, or to kill him. The same
kind of thing can happen in computing when we are unsure of the references
of certain objects. 

Here are some examples learned from natural languages:
\begin{itemize}
    \item Syntactic complexity
        \begin{itemize}
            \item Jack built the house the malt the rat the cat killed ate
                lay in
        \end{itemize}
    \item Syntactic ambiguity
        \begin{itemize}
            \item Let him have it, Chris!
        \end{itemize}
        \item Semantic Complexity
            \begin{itemize}
                \item It depends on what the meaning of the word `is' is!
            \end{itemize}
        \item Semantic ambiguity
            \begin{itemize}
                \item I haven't slept for ten days
            \end{itemize}
            \item Semantic undefinedness
            \begin{itemize}
                \item Colourless green ideas sleep furiously
            \end{itemize}
            \item Interaction of syntax and semantics
                \begin{itemize}
                    \item Time flies like an arrow, fruit flies like a
                        banana.
                \end{itemize}
\end{itemize}

We can apply these things to computing terms, too.
\begin{itemize}
    \item Syntactic complexity
            \begin{lstlisting}
x-=y = (x=x+y) - y      //switches variables x and y
            \end{lstlisting}
    \item Syntactic ambiguity
\begin{lstlisting}
if (...) if (...) ..; else ..       //dangling else
\end{lstlisting}
        \item Semantic Complexity
\begin{lstlisting}
y = x++ + x++       //sequence points
\end{lstlisting}
        \item Semantic ambiguity
\begin{lstlisting}
(x%2=1) ? "odd" : "even"        //unspecified in C89 if x<0
\end{lstlisting}
            \item Semantic undefinedness
\begin{lstlisting}
while(x/x)      //division error or infinite loop
\end{lstlisting}
            \item Interaction of syntax and semantics
\begin{lstlisting}
A * B       //lever hack
\end{lstlisting}

\end{itemize}

To put this another way:
\begin{itemize}
    \item \textbf{Syntax}: concerned with the form of expressions and
        whether or not the program actually \textit{compiles}
    \item \textbf{Semantics}: concerned with the meaning of expressions
        and what the program does when it \textit{runs}
    \item \textbf{Pragmatics}: concerned with issues like design patterns,
        program style, industry standards, etc.
\end{itemize}

\section{Structural Operational Semantics}%
\label{sec:struct-op-semantics}
We're going to look at doing some compilation (of the \textit{while})
language.

\subsection{Termination and looping}%
\label{sub:term-loop}

The execution of the statement $S$ in state $\sigma$ terminates iff there
exists a finite derivation sequence from $\langle S, \sigma \rangle$. The
derivation sequence looks like:
\begin{align*}
    \langle S, \theta\rangle \Rightarrow \gamma_1 \Rightarrow \dots
    \Rightarrow \gamma_n \text{ where } \gamma_n \text{ is terminal }
    \sigma' \text{ or stuck } \langle S', \sigma'\rangle
\end{align*}

The while language never gets stuck, but some language might if we try to
divide by zero because we don't know how to process this.

The execution of the statement $S$ in a state $\theta$ loops iff there
exists an infinite derivation sequence from $\langle S, \sigma \rangle$
\begin{align*}
    \langle S, \sigma \rangle \Rightarrow \gamma_1 \Rightarrow \gamma_2
    \Rightarrow \dots
\end{align*}

$S$ always terminates iff its execution terminates in all states $\sigma$.

$S$ always loops if the execution loops in all states $\sigma$.

The execution of statement $S$ in state $\sigma$ terminates successfully
iff it ends with a terminal configuration.

\textbf{Note} while has no stuck configurations, so termination implies
successful termination!

\subsection{Determinism and Equivalence}%
\label{sub:determinism}
The structural operation semantics is (strongly) \textbf{deterministic}
iff $\langle S, \sigma \rangle \Rightarrow \gamma$ and $\langle S, \sigma
\rangle \Rightarrow \gamma'$ imply that $\gamma = \gamma'$ for all $S,
\sigma, \gamma, \gamma'$

It is \textbf{weakly deterministic} iff $\langle S, \sigma \rangle
\Rightarrow^* \sigma'$ and $\langle S, \sigma \rangle \Rightarrow^*
\sigma''$ imply that $\sigma' = \sigma''$ for all $S, \sigma, \sigma',
\sigma''$. This is different from the strong determinism above because it
says that for every successfully terminating branch, (it doesn't matter
how we get there) we get to the same final state.

Two statements are \textbf{semantically equivalent} whenever it holds that
for \textit{all states} $\sigma$
\begin{align*}
    \langle S_1, \sigma \rangle \Rightarrow^* \gamma \text{ iff } \langle
    S_2, \sigma \rangle
    \Rightarrow^* \gamma \text{ whenever } \gamma \text{ is terminal or
stuck} 
\end{align*}

This means that there is an infinite derivation sequence from $\langle S_1,
\sigma \rangle$ iff there is an infinite derivation from $\langle S_2,
\sigma \rangle$.

\textbf{Note!} The length of these could be different (because of the *
again.)

For a deterministic structural operational semantics, we can define a
semantic function as follows:
\begin{itemize}
    \item $S_{sos} [[.]] \text{ Stm} \rightarrow (\text{State} \pfun
        \text{State})$
\end{itemize}

% TODO finish this lecture


% This is the lecture from 4/11/19 and 8/11/19, so please catch up daddio x
\section{Chain-Complete Partial Orders}%
\label{sec:ccpo}
% TODO this lecture

Sets can have upper and lower bounds depending on where they come in the
order of chains. For example, those at the top of the set are the upper
bound of every element since they are unable to have an upper bound
themselves, while the ones at the bottom are the lower bound, since they
have no lower bound themselves.

\subsection{Definitions of PO-Set (partially ordered set)}%
\label{sub:Definitions of PO-Set}
A PO-Set (D, $\sqsubseteq$) is called a \textit{chain-complete} partially
ordered set (ccpo) whenever the least upper bound $\sqcup y$ exists for
all \underline{chains} $Y \subseteq D$.
\begin{itemize}
    \item To be a CCPO, each chain must have an upper bound
\end{itemize}

Furthermore, a PO-Set (D, $\sqsubseteq$) is called a \textit{complete
lattice} whenever the least upper bound $\sqcup Y$ exists for all
\underline{subsets} $Y\subseteq D$.
\begin{itemize}
    \item To be a lattice, each chain must have a ** %TODO
\end{itemize}

Note that every CCPO (D, $\sqsubseteq$) has a (necessarily unique) element
denoted $\bot = \sqcup \ \emptyset$. This means that it is given by the
lease upper bound of the empty chain. First observe $\emptyset$ is a
chain, since we know that $\emptyset \subseteq D$ by the basic set
properties and $d \sqsubseteq e$ vacuously holds for all $d,e \in
\emptyset$ (of which there are none). So, the least upper bound $\bot$ **
%TODO

The question is: is our relation a chain-complete partial order (from the
slides)? The answer, simply, is no.
\begin{itemize}
    \item This is because we have a whole bunch of items at the end. There
        is no least element of the ordering, so it cannot be a CCPO (this
        is an important part of the CCPO).
\end{itemize}

What we can do is the \textbf{lifted} relation, which we obtain by adding
a least element $\bot$. But, does this now make it a CCPO? Yeah, it does.
Nice. HOWEVER, it does not make it a \textbf{complete lattice}.



\end{document}
