%%=====================================================================================
%%
%%       Filename:  lang-eng.tex
%%
%%    Description:  formal notes for lang-eng
%%
%%        Version:  1.0
%%        Created:  14/10/19
%%       Revision:  none
%%
%%         Author:  Josh Felmeden (), nk18044@bristol.ac.uk
%%   Organization:  
%%      Copyright:  Copyright (c) 2019, Josh Felmeden
%%
%%          Notes:  
%%
%%=====================================================================================

% Preamble {{{
\documentclass[11pt,a4paper,titlepage,dvipsnames,cmyk]{scrartcl}
\usepackage[english]{babel}
\typearea{12}
% }}}

% Set indentation and line skip for paragraph {{{
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}
\usepackage[margin=2cm]{geometry}
\addtolength{\textheight}{-1in}
\setlength{\headsep}{.5in}
% }}}

\usepackage{hhline} 
\usepackage{mathtools} 
\usepackage[T1]{fontenc}

% Headers setup {{{
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Language Engineering - A nice set of notes}
\rhead{Josh Felmeden}
\usepackage{hyperref} 
% }}}

% Listings {{{
\usepackage[]{listings,xcolor} 
\lstset
{
    breaklines=true,
    tabsize=3,
    showstringspaces=false
}

\definecolor{lstgrey}{rgb}{0.05,0.05,0.05}
\usepackage{listings}
\makeatletter
\lstset{language=[Visual]Basic,
    backgroundcolor=\color{lstgrey},
    frame=single,
    xleftmargin=0.7cm,
    frame=tlbr, framesep=0.2cm, framerule=0pt,
    basicstyle=\lst@ifdisplaystyle\color{white}\footnotesize\ttfamily\else\color{black}\footnotesize\ttfamily\fi,
    captionpos=b,
    tabsize=2,
    keywordstyle=\color{Magenta}\bfseries,
    identifierstyle=\color{Cyan},
    stringstyle=\color{Yellow},
    commentstyle=\color{Gray}\itshape
}
\makeatother
\renewcommand{\familydefault}{\sfdefault}
% }}}


% Other packages {{{
\usepackage{needspace}
\usepackage{tcolorbox}
\usepackage{soul}
\usepackage{babel,dejavu,helvet} 
\usepackage{amsmath,amsfonts} 
\usepackage{booktabs} 
\usepackage{tcolorbox} 
\usepackage[symbol]{footmisc} 
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\renewcommand{\familydefault}{\sfdefault}
\newcommand\pfun{\mathrel{\ooalign{\hfil$\mapstochar\mkern5mu$\hfil\cr$\to$\cr}}}
% }}}

% Title {{{
\title{Language Engineering - A nice set of notes}
\author{Josh Felmeden}
% }}}

\begin{document}

\maketitle
\tableofcontents

\newpage

\section{Introduction to Semantics}%
\label{sec:intro-semantics}

Semantics are really complex and they actually exist in the real world as
problems that can arise when the semantics are unclear. In the example of
the Derek Bentley case, Bentley tells Chris (who is holding a gun, and a
policeman standing in front of him to `let him have it!'. Here, it
appears that he could be talking about the gun, or to kill him. The same
kind of thing can happen in computing when we are unsure of the references
of certain objects. 

Here are some examples learned from natural languages:
\begin{itemize}
    \item Syntactic complexity
        \begin{itemize}
            \item Jack built the house the malt the rat the cat killed ate
                lay in
        \end{itemize}
    \item Syntactic ambiguity
        \begin{itemize}
            \item Let him have it, Chris!
        \end{itemize}
        \item Semantic Complexity
            \begin{itemize}
                \item It depends on what the meaning of the word `is' is!
            \end{itemize}
        \item Semantic ambiguity
            \begin{itemize}
                \item I haven't slept for ten days
            \end{itemize}
            \item Semantic undefinedness
            \begin{itemize}
                \item Colourless green ideas sleep furiously
            \end{itemize}
            \item Interaction of syntax and semantics
                \begin{itemize}
                    \item Time flies like an arrow, fruit flies like a
                        banana.
                \end{itemize}
\end{itemize}

We can apply these things to computing terms, too.
\begin{itemize}
    \item Syntactic complexity
            \begin{lstlisting}
x-=y = (x=x+y) - y      //switches variables x and y
            \end{lstlisting}
    \item Syntactic ambiguity
\begin{lstlisting}
if (...) if (...) ..; else ..       //dangling else
\end{lstlisting}
        \item Semantic Complexity
\begin{lstlisting}
y = x++ + x++       //sequence points
\end{lstlisting}
        \item Semantic ambiguity
\begin{lstlisting}
(x%2=1) ? "odd" : "even"        //unspecified in C89 if x<0
\end{lstlisting}
            \item Semantic undefinedness
\begin{lstlisting}
while(x/x)      //division error or infinite loop
\end{lstlisting}
            \item Interaction of syntax and semantics
\begin{lstlisting}
A * B       //lever hack
\end{lstlisting}

\end{itemize}

To put this another way:
\begin{itemize}
    \item \textbf{Syntax}: concerned with the form of expressions and
        whether or not the program actually \textit{compiles}
    \item \textbf{Semantics}: concerned with the meaning of expressions
        and what the program does when it \textit{runs}
    \item \textbf{Pragmatics}: concerned with issues like design patterns,
        program style, industry standards, etc.
\end{itemize}

% 21/10/19
\section{Structural Operational Semantics}%
\label{sec:struct-op-semantics}
We're going to look at doing some compilation (of the \textit{while})
language.

\subsection{Termination and looping}%
\label{sub:term-loop}

The execution of the statement $S$ in state $\sigma$ terminates iff there
exists a finite derivation sequence from $\langle S, \sigma \rangle$. The
derivation sequence looks like:
\begin{align*}
    \langle S, \theta\rangle \Rightarrow \gamma_1 \Rightarrow \dots
    \Rightarrow \gamma_n \text{ where } \gamma_n \text{ is terminal }
    \sigma' \text{ or stuck } \langle S', \sigma'\rangle
\end{align*}

The while language never gets stuck, but some language might if we try to
divide by zero because we don't know how to process this.

The execution of the statement $S$ in a state $\theta$ loops iff there
exists an infinite derivation sequence from $\langle S, \sigma \rangle$
\begin{align*}
    \langle S, \sigma \rangle \Rightarrow \gamma_1 \Rightarrow \gamma_2
    \Rightarrow \dots
\end{align*}

$S$ always terminates iff its execution terminates in all states $\sigma$.

$S$ always loops if the execution loops in all states $\sigma$.

The execution of statement $S$ in state $\sigma$ terminates successfully
iff it ends with a terminal configuration.

\textbf{Note} while has no stuck configurations, so termination implies
successful termination!

\subsection{Determinism and Equivalence}%
\label{sub:determinism}
The structural operation semantics is (strongly) \textbf{deterministic}
iff $\langle S, \sigma \rangle \Rightarrow \gamma$ and $\langle S, \sigma
\rangle \Rightarrow \gamma'$ imply that $\gamma = \gamma'$ for all $S,
\sigma, \gamma, \gamma'$

It is \textbf{weakly deterministic} iff $\langle S, \sigma \rangle
\Rightarrow^* \sigma'$ and $\langle S, \sigma \rangle \Rightarrow^*
\sigma''$ imply that $\sigma' = \sigma''$ for all $S, \sigma, \sigma',
\sigma''$. This is different from the strong determinism above because it
says that for every successfully terminating branch, (it doesn't matter
how we get there) we get to the same final state.

Two statements are \textbf{semantically equivalent} whenever it holds that
for \textit{all states} $\sigma$
\begin{align*}
    \langle S_1, \sigma \rangle \Rightarrow^* \gamma \text{ iff } \langle
    S_2, \sigma \rangle
    \Rightarrow^* \gamma \text{ whenever } \gamma \text{ is terminal or
stuck} 
\end{align*}

This means that there is an infinite derivation sequence from $\langle S_1,
\sigma \rangle$ iff there is an infinite derivation from $\langle S_2,
\sigma \rangle$.

\textbf{Note!} The length of these could be different (because of the *
again.)

For a deterministic structural operational semantics, we can define a
semantic function as follows:
\begin{itemize}
    \item $S_{sos} [[.]] \text{ Stm} \rightarrow (\text{State} \pfun
        \text{State})$
    \item $S_{sos} [[S]] \sigma = \sigma'$ if $\langle S, \sigma \rangle
        \Rightarrow^* \sigma'$ and \textbf{undefined} otherwise
    \item Note that the semantic function is only guaranteed to return a
        partial function between states due to the existence of statements
        whose execution loops in one or more states
    \item $S_{sos} [[\text{ while true do skip }]] = \{\}$
    \begin{itemize}
        \item If we apply this on any state, we get undefined back BUT it
            is not in and of itself undefined. It is simply the empty set.
        \item What could we do if the semantics is not deterministic?
        \begin{itemize}
            \item The problem is that depending on what choice we made, we
                might get a different answer. But the definition says that we
                only return one function. So therefore, we need to be able to
                collect them up into a list.
            \item One way of doing it is: $S'_{sos} [[.]] : \text{ Stm} \pfun
                (\text{State} \pfun \text{ State})$ to ignore the ambiguous
                cases
            \item Another way is to allow a set of final states: $S''_{sos}
                [[.]]: \text{ Stm} \rightarrow (\text{State} \rightarrow
                \mathcal{P} \text{ State})$. This is bad because we get a
                set of states.
            \item $S'''_{sos}[[.]]: \text{ Stm} \rightarrow
                (\mathcal{P}(\text{State}) \rightarrow
                \mathcal{P}(\text{State}))$ now facilitates function
                composition. Basically, we pass a load of states, and the
                function returns a list of all functions that can be
                reached from any of those functions.
        \end{itemize}
    \end{itemize}
\end{itemize}

\newpage
\textbf{Theorem.} For all statements $S$ of \textbf{While}, it holds that
$S_{ns}[[S]] = S_{sos}[[S]]$. Basically, for all statements, then:
\begin{align*}
    \{(\sigma, \sigma') \in \text{ State}^2 \ | \ \langle S, \sigma \rangle
        \rightarrow \sigma' \} = \{(\sigma, \sigma') \in \text{ State}^2 \
        | \
    \langle S, \sigma \rangle \Rightarrow ^* \sigma'\}
\end{align*}

This mess can be decomposed into two different facts:
\begin{align*}
    \langle S, \sigma \rangle \Rightarrow ^* \sigma' \text{ implies }
    \langle S, \sigma \rangle \rightarrow \sigma'
\end{align*}

And
\begin{align*}
    \langle S, \sigma \rangle \rightarrow \sigma' \text{ implies }
    \langle S, \sigma \rangle \Rightarrow^* \sigma'
\end{align*}

Very subtle, right? This can also be decomposed further into some cool
stuff but I don't think it's helpful. See lemma 2.28 in the book for the
derivation sequence.

\subsection{Provably correct implementation}%
\label{sub:Provably correct implementation}
We're now going to look at the correctness of a compiler from
\textbf{While} to an abstract machine \textbf{AM}. Initially, we will
consider a simple \textbf{stack} machine with a set of abstract
instructions. Later on, we'll refine it to use memory addresses. Let's
formalise some aspects of the abstract machine.

The configurations in the machine are going to be a triple: $\langle c, e,
s \rangle$:
\begin{itemize}
    \item $c$ is the code to be executed $c \in$ Code $= \text{ inst}^*$
    \item $e$ is the evaluation stack (of expressions) $e \in$ Stack $= (Z
        \cup T)^*$
    \item $s$ is the storage (for variables) $s \in$ State $= \text{ Var }
        \rightarrow Z$
\end{itemize}

The instructions will be:

\begin{lstlisting}
inst ::= push-n | add | mult | sub
        | true | false | eq | le | and | neg
        | fetch-x | store-x | noop | branch(c,c) | loop(c,c)

c ::= empty | inst:c
\end{lstlisting}

\lstinline|noop| is basically a skip. Also, we'll be passing around code
in this example, but later on we'll replace the `code' by memory addresses
where the code is stored.

\subsubsection{Arithmetic code}%
\label{ssub:code-1}
At this point, we might have the following code:
\begin{align*}
    &\langle \text{PUSH-n:}c, e, s \rangle &  &\triangleright & &\langle c,
    \mathcal{N}[[n]] \text{:}e, s \rangle \\
    &\langle \text{ADD:}c, z_1 \text{:} z_2 \text{:}e, s \rangle & &\triangleright & &\langle c,
    (z_1 * z_2) \text{:}e, s \rangle & &\text{ if } z_1, z_2 \in \mathbb{Z} \\
     &\langle \text{TRUE:}c, e, s \rangle & &\triangleright & &\langle c,
     \textbf{tt}\text{:}e, s \rangle \\
     &\langle \text{EQ:}c, z_1 \text{:} z_2 \text{:}e, s \rangle & &\triangleright &
     &\langle c, (z_1 = z_2) \text{:}e, s \rangle & &\text{ if } z_1,z_2 \in
     \mathbb{Z}
\end{align*}
Here, the `:' is much like the `cons' function from Haskell, in that if we
take ADD for example; ADD:$c$ means that we have the statement ADD, and
then more code following it. In the same way, with the arguments of ADD,
we need two integers $z_1, z_2$ on the stack, represented by $z_1 : z_2 :
e$.

Obviously, there are more keywords, but they follow the same format as
these existing ones.

\subsubsection{State changing code}%
\label{ssub:code-2}
Now, let's look at some of the state rules:
\begin{align*}
    &\langle \text{FETCH-x:}c, e, s \rangle & &\triangleright & &\langle c,
    s(s x)\text{:}e, s \rangle \\
    &\langle \text{STORE-x:}c, z\text{:}e, s \rangle & &\triangleright &
    &\langle c, e, s[x \mapsto z] \rangle & &\text{if } z \in \mathbb{Z} \\
    &\langle \text{NOOP:}c, e, s \rangle & &\triangleright & &\langle c,
    e, s \rangle \\
    &\langle \text{BRANCH}(c_1, c_2)\text{:}c, t\text{:}e, s
    & &\triangleright &\bigg \{ \
    \begin{split}
    &\langle c_1 \text{:} c, e, s \rangle 
    \\
    & \langle c_2 \text{:} c, e, s \rangle 
    \end{split}
    &\begin{split}
        &\text{if } t = \textbf{ tt} \\
        &\text{if } t = \textbf{ ff}
    \end{split} \\
    &\langle \text{LOOP}(c_2, c_2) \text{:}c, e, s \rangle &
    &\triangleright & &\langle c_1
\text{:BRANCH}(c_2\text{:LOOP}(c_1,c_2), \text{NOOP})\text{:}c, e, s\rangle
\end{align*}

\subsubsection{Computation sequences}%
\label{ssub:Computation sequences}
\begin{itemize}
    \item A configuration $\gamma$ can have one of two forms. It can either be
        \textbf{incomplete} or \textbf{terminal}.
    \item An incomplete configuration be either \textbf{stuck} if there is
        no $\gamma'$ such that $\gamma
        \triangleright \gamma'$, OR it is \textbf{unstuck} if the opposite is
        true.
    \item A computation sequence from $\langle c, \epsilon, \sigma$ is
        either a \textbf{finite sequence} such that all $\gamma$ is a
        terminal or stuck configuration, or it is \textbf{infinite}, such
        that $\gamma_0 = \langle c, \epsilon, \sigma \rangle$ and
        $\gamma_i \triangleright \gamma_{i+1}$ for all $0 \le i$.
    \item \textbf{Note!} $\gamma \triangleright ^k \gamma'$ means that
        $\gamma'$ can be obtained from $\gamma$ in exactly $k$ steps of
        $\triangleright$.
    \item \textbf{Note!} $\gamma \triangleright ^* \gamma'$ means that
        $\gamma'$ can be obtained from $\gamma$ in a \textit{finite}
        number of steps.
\end{itemize}

Termination and looping is pretty basic and expected, so I won't cover
that here.

% This is the lecture from 4/11/19 and 8/11/19, so please catch up daddio x
\section{Chain-Complete Partial Orders}%
\label{sec:ccpo}
% TODO this lecture

Sets can have upper and lower bounds depending on where they come in the
order of chains. For example, those at the top of the set are the upper
bound of every element since they are unable to have an upper bound
themselves, while the ones at the bottom are the lower bound, since they
have no lower bound themselves.

\subsection{Definitions of PO-Set (partially ordered set)}%
\label{sub:Definitions of PO-Set}
A PO-Set (D, $\sqsubseteq$) is called a \textit{chain-complete} partially
ordered set (ccpo) whenever the least upper bound $\sqcup y$ exists for
all \underline{chains} $Y \subseteq D$.
\begin{itemize}
    \item To be a CCPO, each chain must have an upper bound
\end{itemize}

Furthermore, a PO-Set (D, $\sqsubseteq$) is called a \textit{complete
lattice} whenever the least upper bound $\sqcup Y$ exists for all
\underline{subsets} $Y\subseteq D$.
\begin{itemize}
    \item To be a lattice, each chain must have a ** %TODO
\end{itemize}

Note that every CCPO (D, $\sqsubseteq$) has a (necessarily unique) element
denoted $\bot = \sqcup \ \emptyset$. This means that it is given by the
lease upper bound of the empty chain. First observe $\emptyset$ is a
chain, since we know that $\emptyset \subseteq D$ by the basic set
properties and $d \sqsubseteq e$ vacuously holds for all $d,e \in
\emptyset$ (of which there are none). So, the least upper bound $\bot$ **
%TODO

The question is: is our relation a chain-complete partial order (from the
slides)? The answer, simply, is no.
\begin{itemize}
    \item This is because we have a whole bunch of items at the end. There
        is no least element of the ordering, so it cannot be a CCPO (this
        is an important part of the CCPO).
\end{itemize}

What we can do is the \textbf{lifted} relation, which we obtain by adding
a least element $\bot$. But, does this now make it a CCPO? Yeah, it does.
Nice. HOWEVER, it does not make it a \textbf{complete lattice}.

\end{document}
