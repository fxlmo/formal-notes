%%=====================================================================================
%%
%%       Filename:  lang-eng.tex
%%
%%    Description:  formal notes for lang-eng
%%
%%        Version:  1.0
%%        Created:  14/10/19
%%       Revision:  none
%%
%%         Author:  Josh Felmeden (), nk18044@bristol.ac.uk
%%   Organization:  
%%      Copyright:  Copyright (c) 2019, Josh Felmeden
%%
%%          Notes:  
%%
%%=====================================================================================

% Preamble {{{
\documentclass[11pt,a4paper,titlepage,dvipsnames,cmyk]{scrartcl}
\usepackage[english]{babel}
\typearea{12}
% }}}

% Set indentation and line skip for paragraph {{{
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}
\usepackage[margin=2cm]{geometry}
\addtolength{\textheight}{-1in}
\setlength{\headsep}{.5in}
% }}}

\usepackage{hhline} 
\usepackage{mathtools} 
\usepackage[T1]{fontenc}

% Headers setup {{{
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Language Engineering - A nice set of notes}
\rhead{Josh Felmeden}
\usepackage{hyperref} 
% }}}

% Listings {{{
\usepackage[]{listings,xcolor} 
\lstset
{
    breaklines=true,
    tabsize=3,
    showstringspaces=false
}

\definecolor{lstgrey}{rgb}{0.05,0.05,0.05}
\usepackage{listings}
\makeatletter
\lstset{language=[Visual]Basic,
    backgroundcolor=\color{lstgrey},
    frame=single,
    xleftmargin=0.7cm,
    frame=tlbr, framesep=0.2cm, framerule=0pt,
    basicstyle=\lst@ifdisplaystyle\color{white}\footnotesize\ttfamily\else\color{black}\footnotesize\ttfamily\fi,
    captionpos=b,
    tabsize=2,
    keywordstyle=\color{Magenta}\bfseries,
    identifierstyle=\color{Cyan},
    stringstyle=\color{Yellow},
    commentstyle=\color{Gray}\itshape
}
\makeatother
\renewcommand{\familydefault}{\sfdefault}
% }}}


% Other packages {{{
\usepackage{needspace}
\usepackage{tcolorbox}
\usepackage{soul}
\usepackage{babel,dejavu,helvet} 
\usepackage{amsmath,amsfonts} 
\usepackage{booktabs} 
\usepackage{tcolorbox} 
\usepackage[symbol]{footmisc} 
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\renewcommand{\familydefault}{\sfdefault}
\newcommand\pfun{\hookrightarrow}
% }}}

% Title {{{
\title{Language Engineering - A nice set of notes}
\author{Josh Felmeden}
% }}}

\begin{document}

\maketitle
\tableofcontents

\newpage

\section{Introduction to Semantics}%
\label{sec:intro-semantics}

Semantics are really complex and they actually exist in the real world as
problems that can arise when the semantics are unclear. In the example of
the Derek Bentley case, Bentley tells Chris (who is holding a gun, and a
policeman standing in front of him to `let him have it!'. Here, it
appears that he could be talking about the gun, or to kill him. The same
kind of thing can happen in computing when we are unsure of the references
of certain objects. 

Here are some examples learned from natural languages:
\begin{itemize}
    \item Syntactic complexity
        \begin{itemize}
            \item Jack built the house the malt the rat the cat killed ate
                lay in
        \end{itemize}
    \item Syntactic ambiguity
        \begin{itemize}
            \item Let him have it, Chris!
        \end{itemize}
        \item Semantic Complexity
            \begin{itemize}
                \item It depends on what the meaning of the word `is' is!
            \end{itemize}
        \item Semantic ambiguity
            \begin{itemize}
                \item I haven't slept for ten days
            \end{itemize}
            \item Semantic undefinedness
            \begin{itemize}
                \item Colourless green ideas sleep furiously
            \end{itemize}
            \item Interaction of syntax and semantics
                \begin{itemize}
                    \item Time flies like an arrow, fruit flies like a
                        banana.
                \end{itemize}
\end{itemize}

We can apply these things to computing terms, too.
\begin{itemize}
    \item Syntactic complexity
            \begin{lstlisting}
x-=y = (x=x+y) - y      //switches variables x and y
            \end{lstlisting}
    \item Syntactic ambiguity
\begin{lstlisting}
if (...) if (...) ..; else ..       //dangling else
\end{lstlisting}
        \item Semantic Complexity
\begin{lstlisting}
y = x++ + x++       //sequence points
\end{lstlisting}
        \item Semantic ambiguity
\begin{lstlisting}
(x%2=1) ? "odd" : "even"        //unspecified in C89 if x<0
\end{lstlisting}
            \item Semantic undefinedness
\begin{lstlisting}
while(x/x)      //division error or infinite loop
\end{lstlisting}
            \item Interaction of syntax and semantics
\begin{lstlisting}
A * B       //lever hack
\end{lstlisting}

\end{itemize}

To put this another way:
\begin{itemize}
    \item \textbf{Syntax}: concerned with the form of expressions and
        whether or not the program actually \textit{compiles}
    \item \textbf{Semantics}: concerned with the meaning of expressions
        and what the program does when it \textit{runs}
    \item \textbf{Pragmatics}: concerned with issues like design patterns,
        program style, industry standards, etc.
\end{itemize}

% 21/10/19
\section{Structural Operational Semantics}%
\label{sec:struct-op-semantics}
We're going to look at doing some compilation (of the \textit{while})
language.

\subsection{Termination and looping}%
\label{sub:term-loop}

The execution of the statement $S$ in state $\sigma$ terminates iff there
exists a finite derivation sequence from $\langle S, \sigma \rangle$. The
derivation sequence looks like:
\begin{align*}
    \langle S, \theta\rangle \Rightarrow \gamma_1 \Rightarrow \dots
    \Rightarrow \gamma_n \text{ where } \gamma_n \text{ is terminal }
    \sigma' \text{ or stuck } \langle S', \sigma'\rangle
\end{align*}

The while language never gets stuck, but some language might if we try to
divide by zero because we don't know how to process this.

The execution of the statement $S$ in a state $\theta$ loops iff there
exists an infinite derivation sequence from $\langle S, \sigma \rangle$
\begin{align*}
    \langle S, \sigma \rangle \Rightarrow \gamma_1 \Rightarrow \gamma_2
    \Rightarrow \dots
\end{align*}

$S$ always terminates iff its execution terminates in all states $\sigma$.

$S$ always loops if the execution loops in all states $\sigma$.

The execution of statement $S$ in state $\sigma$ terminates successfully
iff it ends with a terminal configuration.

\textbf{Note} while has no stuck configurations, so termination implies
successful termination!

\subsection{Determinism and Equivalence}%
\label{sub:determinism}
The structural operation semantics is (strongly) \textbf{deterministic}
iff $\langle S, \sigma \rangle \Rightarrow \gamma$ and $\langle S, \sigma
\rangle \Rightarrow \gamma'$ imply that $\gamma = \gamma'$ for all $S,
\sigma, \gamma, \gamma'$

It is \textbf{weakly deterministic} iff $\langle S, \sigma \rangle
\Rightarrow^* \sigma'$ and $\langle S, \sigma \rangle \Rightarrow^*
\sigma''$ imply that $\sigma' = \sigma''$ for all $S, \sigma, \sigma',
\sigma''$. This is different from the strong determinism above because it
says that for every successfully terminating branch, (it doesn't matter
how we get there) we get to the same final state.

Two statements are \textbf{semantically equivalent} whenever it holds that
for \textit{all states} $\sigma$
\begin{align*}
    \langle S_1, \sigma \rangle \Rightarrow^* \gamma \text{ iff } \langle
    S_2, \sigma \rangle
    \Rightarrow^* \gamma \text{ whenever } \gamma \text{ is terminal or
stuck} 
\end{align*}

This means that there is an infinite derivation sequence from $\langle S_1,
\sigma \rangle$ iff there is an infinite derivation from $\langle S_2,
\sigma \rangle$.

\textbf{Note!} The length of these could be different (because of the *
again.)

For a deterministic structural operational semantics, we can define a
semantic function as follows:
\begin{itemize}
    \item $S_{sos} [[.]] \text{ Stm} \rightarrow (\text{State} \pfun
        \text{State})$
    \item $S_{sos} [[S]] \sigma = \sigma'$ if $\langle S, \sigma \rangle
        \Rightarrow^* \sigma'$ and \textbf{undefined} otherwise
    \item Note that the semantic function is only guaranteed to return a
        partial function between states due to the existence of statements
        whose execution loops in one or more states
    \item $S_{sos} [[\text{ while true do skip }]] = \{\}$
    \begin{itemize}
        \item If we apply this on any state, we get undefined back BUT it
            is not in and of itself undefined. It is simply the empty set.
        \item What could we do if the semantics is not deterministic?
        \begin{itemize}
            \item The problem is that depending on what choice we made, we
                might get a different answer. But the definition says that we
                only return one function. So therefore, we need to be able to
                collect them up into a list.
            \item One way of doing it is: $S'_{sos} [[.]] : \text{ Stm} \pfun
                (\text{State} \pfun \text{ State})$ to ignore the ambiguous
                cases
            \item Another way is to allow a set of final states: $S''_{sos}
                [[.]]: \text{ Stm} \rightarrow (\text{State} \rightarrow
                \mathcal{P} \text{ State})$. This is bad because we get a
                set of states.
            \item $S'''_{sos}[[.]]: \text{ Stm} \rightarrow
                (\mathcal{P}(\text{State}) \rightarrow
                \mathcal{P}(\text{State}))$ now facilitates function
                composition. Basically, we pass a load of states, and the
                function returns a list of all functions that can be
                reached from any of those functions.
        \end{itemize}
    \end{itemize}
\end{itemize}

\newpage
\textbf{Theorem.} For all statements $S$ of \textbf{While}, it holds that
$S_{ns}[[S]] = S_{sos}[[S]]$. Basically, for all statements, then:
\begin{align*}
    \{(\sigma, \sigma') \in \text{ State}^2 \ | \ \langle S, \sigma \rangle
        \rightarrow \sigma' \} = \{(\sigma, \sigma') \in \text{ State}^2 \
        | \
    \langle S, \sigma \rangle \Rightarrow ^* \sigma'\}
\end{align*}

This mess can be decomposed into two different facts:
\begin{align*}
    \langle S, \sigma \rangle \Rightarrow ^* \sigma' \text{ implies }
    \langle S, \sigma \rangle \rightarrow \sigma'
\end{align*}

And
\begin{align*}
    \langle S, \sigma \rangle \rightarrow \sigma' \text{ implies }
    \langle S, \sigma \rangle \Rightarrow^* \sigma'
\end{align*}

Very subtle, right? This can also be decomposed further into some cool
stuff but I don't think it's helpful. See lemma 2.28 in the book for the
derivation sequence.

\subsection{Provably correct implementation}%
\label{sub:Provably correct implementation}
We're now going to look at the correctness of a compiler from
\textbf{While} to an abstract machine \textbf{AM}. Initially, we will
consider a simple \textbf{stack} machine with a set of abstract
instructions. Later on, we'll refine it to use memory addresses. Let's
formalise some aspects of the abstract machine.

The configurations in the machine are going to be a triple: $\langle c, e,
s \rangle$:
\begin{itemize}
    \item $c$ is the code to be executed $c \in$ Code $= \text{ inst}^*$
    \item $e$ is the evaluation stack (of expressions) $e \in$ Stack $= (Z
        \cup T)^*$
    \item $s$ is the storage (for variables) $s \in$ State $= \text{ Var }
        \rightarrow Z$
\end{itemize}

The instructions will be:

\begin{lstlisting}
inst ::= push-n | add | mult | sub
        | true | false | eq | le | and | neg
        | fetch-x | store-x | noop | branch(c,c) | loop(c,c)

c ::= empty | inst:c
\end{lstlisting}

\lstinline|noop| is basically a skip. Also, we'll be passing around code
in this example, but later on we'll replace the `code' by memory addresses
where the code is stored.

\subsubsection{Arithmetic code}%
\label{ssub:code-1}
At this point, we might have the following code:
\begin{align*}
    &\langle \text{PUSH-n:}c, e, s \rangle &  &\triangleright & &\langle c,
    \mathcal{N}[[n]] \text{:}e, s \rangle \\
    &\langle \text{ADD:}c, z_1 \text{:} z_2 \text{:}e, s \rangle & &\triangleright & &\langle c,
    (z_1 * z_2) \text{:}e, s \rangle & &\text{ if } z_1, z_2 \in \mathbb{Z} \\
     &\langle \text{TRUE:}c, e, s \rangle & &\triangleright & &\langle c,
     \textbf{tt}\text{:}e, s \rangle \\
     &\langle \text{EQ:}c, z_1 \text{:} z_2 \text{:}e, s \rangle & &\triangleright &
     &\langle c, (z_1 = z_2) \text{:}e, s \rangle & &\text{ if } z_1,z_2 \in
     \mathbb{Z}
\end{align*}
Here, the `:' is much like the `cons' function from Haskell, in that if we
take ADD for example; ADD:$c$ means that we have the statement ADD, and
then more code following it. In the same way, with the arguments of ADD,
we need two integers $z_1, z_2$ on the stack, represented by $z_1 : z_2 :
e$.

Obviously, there are more keywords, but they follow the same format as
these existing ones.

\subsubsection{State changing code}%
\label{ssub:code-2}
Now, let's look at some of the state rules:
\begin{align*}
    &\langle \text{FETCH-x:}c, e, s \rangle & &\triangleright & &\langle c,
    s(s x)\text{:}e, s \rangle \\
    &\langle \text{STORE-x:}c, z\text{:}e, s \rangle & &\triangleright &
    &\langle c, e, s[x \mapsto z] \rangle & &\text{if } z \in \mathbb{Z} \\
    &\langle \text{NOOP:}c, e, s \rangle & &\triangleright & &\langle c,
    e, s \rangle \\
    &\langle \text{BRANCH}(c_1, c_2)\text{:}c, t\text{:}e, s
    & &\triangleright &\bigg \{ \
    \begin{split}
    &\langle c_1 \text{:} c, e, s \rangle 
    \\
    & \langle c_2 \text{:} c, e, s \rangle 
    \end{split}
    &\begin{split}
        &\text{if } t = \textbf{ tt} \\
        &\text{if } t = \textbf{ ff}
    \end{split} \\
    &\langle \text{LOOP}(c_2, c_2) \text{:}c, e, s \rangle &
    &\triangleright & &\langle c_1
\text{:BRANCH}(c_2\text{:LOOP}(c_1,c_2), \text{NOOP})\text{:}c, e, s\rangle
\end{align*}

\subsubsection{Computation sequences}%
\label{ssub:Computation sequences}
\begin{itemize}
    \item A configuration $\gamma$ can have one of two forms. It can either be
        \textbf{incomplete} or \textbf{terminal}.
    \item An incomplete configuration be either \textbf{stuck} if there is
        no $\gamma'$ such that $\gamma
        \triangleright \gamma'$, OR it is \textbf{unstuck} if the opposite is
        true.
    \item A computation sequence from $\langle c, \epsilon, \sigma$ is
        either a \textbf{finite sequence} such that all $\gamma$ is a
        terminal or stuck configuration, or it is \textbf{infinite}, such
        that $\gamma_0 = \langle c, \epsilon, \sigma \rangle$ and
        $\gamma_i \triangleright \gamma_{i+1}$ for all $0 \le i$.
    \item \textbf{Note!} $\gamma \triangleright ^k \gamma'$ means that
        $\gamma'$ can be obtained from $\gamma$ in exactly $k$ steps of
        $\triangleright$.
    \item \textbf{Note!} $\gamma \triangleright ^* \gamma'$ means that
        $\gamma'$ can be obtained from $\gamma$ in a \textit{finite}
        number of steps.
\end{itemize}

Termination and looping is pretty basic and expected, so I won't cover
that here.

%Lecture: 25/10/19
\subsection{The execution function}%
\label{sub:exec-func}
We can define an execution function for our abstract machine (AM) as
follows:
\begin{itemize}
    \item $\mathcal{M}[\![.]\!]$: Code $\rightarrow (\text{State} \pfun
        \text{State})$
    \item $\mathcal{M}[\![c]\!] \sigma = $
        \begin{align*}
            \Bigg \{ 
                \begin{split}
                    \sigma' \quad &\text{if } \langle c, \epsilon, \sigma' \rangle
                    \triangleright^* \langle \epsilon, e, \sigma' \rangle \\
                    (\text{Undefined} \quad &\text{otherwise})
                \end{split}
        \end{align*}
\end{itemize}

\subsection{Code Translation of Expressions}%
\label{sub:code-translation}
Now, we're looking at a function that can translate from \textbf{while}
into this AM code. So, $\mathcal{CA} [\![.]\!]$: Aexp $\rightarrow$ Code.

\begin{alignat*}{2}
   &\mathcal{CA} [\![n]\!] &&= \text{PUSH-n } \\
   &\mathcal{CA} [\![x]\!] &&= \text{FETCH-n } \\
   &\mathcal{CA} [\![a_1 + a_2]\!] &&= \mathcal{CA}[\![a_2]\!] :
   \mathcal{CA}[\![a_1]\!]:\text{ADD} \\
   &\mathcal{CA} [\![a_1 * a_2]\!] &&= \mathcal{CA}[\![a_2]\!] :
   \mathcal{CA}[\![a_1]\!]:\text{MULT} \\
   &\mathcal{CA} [\![a_1 - a_2]\!] &&= \mathcal{CA}[\![a_2]\!] :
   \mathcal{CA}[\![a_1]\!]:\text{SUB} \\
\end{alignat*}

For the arithmetic ones, we need to take care because with subtraction,
the order matters, hence $a_2$ being pushed onto the stack before $a_1$

Now, we can look at $\mathcal{CB} [\![.]\!]$: Bexp $\rightarrow$ Code (the
binary ones).
\begin{alignat*}{2}
   &\mathcal{CB} [\![\text{true}]\!] &&= \text{TRUE} \\
   &\mathcal{CB} [\![\text{false}]\!] &&= \text{FALSE} \\
   &\mathcal{CB} [\![a_1 = a_2]\!] &&=
   \mathcal{CA}[\![a_2]\!]:\mathcal{CA}[\![a_1]\!]:\text{EQ} \\
   &\mathcal{CB} [\![a_1 \le a_2]\!] &&=
   \mathcal{CA}[\![a_2]\!]:\mathcal{CA}[\![a_1]\!]:\text{LE}\\
   &\mathcal{CB}[\![\neg b]\!] &&= \mathcal{CB}[\![b]\!]:\text{NEG} \\
   &\mathcal{CB} [\![b_1 \wedge b_2]\!] &&=
   \mathcal{CB}[\![b_2]\!]:\mathcal{CB}[\![b_1]\!]:\text{AND}
\end{alignat*}

We have to use the \textbf{stack} rather than work directly with the
results.

Finally, we need to translate statements: $\mathcal{CS} [\![.]\!]$: Stm
$\rightarrow$ Code.

\begin{alignat*}{2}
    &\mathcal{CS}[\![x:=a]\!] &&= \mathcal{CA}[\![a]\!]:\text{STORE-x} \\
    &\mathcal{CS}[\![\text{skip}]\!] &&= \text{NOOP} \\
    &\mathcal{CS}[\![S_1;S_2]\!] &&= \mathcal{CS}[\![S_1]]:\mathcal{CS}[\![S_2]] \\
    &\mathcal{CS}[\![\text{if } b \text{ then } S_1 \text{ else } S_2]\!] &&= \mathcal{CB}[\![b]\!]:\text{BRANCH}(\mathcal{CS}[\![S_1]\!],\mathcal{CS}[\![S_2]\!]) \\
    &\mathcal{CS}[\![\text{while } b \text{ do } S]\!] &&= \text{LOOP}(\mathcal{CB}[\![b]\!],\mathcal{CS}[\![S]\!])
\end{alignat*}

\subsection{Semantic function}%
\label{sub:Semantic-function}
We can now define a semantic function for \textbf{While} (by translating
and executing the program on our AM), and it will be called $S_{am}$.
\begin{align*}
    &\mathcal{S}_{am} [\![.]\!]: \rightarrow (\text{State}\pfun\text{State}) \\
    &\mathcal{S}_{am} [\![.]\!] = \sigma' \text{ if }
    \mathcal{M}[\![\mathcal{CS}[\![]\!]\!] \sigma = \sigma', \text{
    Undefined otherwise } \\
    &\mathcal{S}_{am} [\![S]\!] \sigma = (\mathcal{M} ^o
    \mathcal{CS})[\![S]\!] \sigma \\
    &\mathcal{S}_{am} [\![S]\!] = (\mathcal{M} ^o
    \mathcal{CS})[\![S]\!] \\
\end{align*}

Here's an example using factorials:
\begin{align*}
    &\mathcal{CS} [\![\text{y:=1, while } \neg (x=1) \text{ do } (y:=y * x;
    x:=x-1)]\!] \\
    = \ &\mathcal{CS}[\![y:=1]\!]: \\
      &\mathcal{ CS}[\![\text{while } \neg (x=1) \text{ do }
      (y:=y*x;x:=x-1)]\!] \\
    = \ &\mathcal{CA}[\![1]\!]: \text{ store-y }: \\
      &\text{loop}(\mathcal{CB}[\![y:=y * x; x:= x-1]\!]) \\
    = \ &\text{push-1}: \text{store-y}: \\
      &\text{loop}(\mathcal{CB}[\![x=1]\!]: \text{neg}, \\
      &\quad \quad \mathcal{CS}[\![y:=y * x]\!] : \mathcal{CS}[\![x:=x-1]\!])\\
    &\dots \\
    = \ &\text{push-1}:\text{store-y}: \\
    &\text{loop}(\text{push-1 : fetch-x : eq : neg,} \\
    &\quad \quad \text{fetch-x : fetch-y : mult : store-y :} \\
    &\quad  \quad\text{push-1 : fetch-x : sub : store-x})
\end{align*}

Because we have specified the functions, they are allowed to be undefined
(such as when they do infinite loops). 

\subsubsection{Correctness of translation}%
\label{ssub:correctness-translation}
We can say that for any arithmetic expression, all intermediate
configurations have a non-empty stack. 

Similarly, for all boolean expressions $b$, all intermediate
configurations have a non-empty stack.

\textbf{Note!} We don't have to always change state because we defined the
program. In fact, if we wanted to allow $\mathcal{A}[\![.]\!]$ to allow
state changes, we'd have to change the definition of $\mathcal{A}$. That
is to say, if we want to allow `side-effects', we'd need to change the
definition to allow it to return both an integer and a state $S$.

%Lecture from 28/10/19
\section{Denotational Semantics}%
\label{sec:denotational-semantics}
A denotational semantics defines the meaning of a program by a partial
function called a \textbf{state-transformer} from (initial) states to
(final) states. We're gonna be operating at a level that takes functions
as arguments, and gives arguments.

A denotational semantics must be \textbf{compositional}. This means we
must define the meaning of expressions in terms of their
\textit{sub-expressions}.

There are two flavours of denotational semantics: \textbf{direct-style}
and \textbf{continuation-style}. We'll mostly look at the first flavour.

We need two more notions to formalise the meaning of if-then-else, and
while statements. For this, we'll use \textbf{conditional functions} and
\textbf{fixpoint operators}.

The denotational semantics of \textbf{While} statements is specified in a
similar way to the functions for arithmetic and boolean operations.

So, we define the direct-style semantic function to be:
\begin{align*}
    S_{ds} \quad : \quad: \text{Stm } \rightarrow ( \text{State } \pfun
    \text{ State})
\end{align*}

Here is what the semantics looks like:
\begin{align*}
    &\mathcal{S}_{ds} [\![x:=a]\!] s = s[x \mapsto \mathcal{A}[\![a]\!]s]
    \\
    &\mathcal{S}_{ds}[\![\text{skip}]\!] = id \\
    &\mathcal{S}_{ds}[\![S_1;S_2]\!] =
    \mathcal{S}_{ds}[\![S_2]\!]^o\mathcal{S}_{ds}[\![S_1]\!] \\
    &\mathcal{S}_{ds}[\![\text{if } b \text{ then } S_1 \text{ else }
    S_2]\!] =
    \text{cond}(\mathcal{B}[\![b]\!],\mathcal{S}_{ds}[\![S_1]\!],\mathcal{S}_{ds}[\![S_2]\!]) \\
    &\mathcal{S}_{ds}[\![\text{while } b \text{ do } S]\!] = \text{FIX F
    where} F g =
    \text{cond}(\mathcal{B}[\![b]\!],g^o\mathcal{S}_{ds}[\![S]\!],id)
\end{align*}

`FIX F' is the (least) fixpoint of the \textbf{functional} F, which is the
functional of the loop. The g is an implicit argument of the functional F.
We'll look at this a bit more, cause it's quite rough.

\subsection{Conditional functions}%
\label{sub:conditional-func}
The idea of a \textbf{conditional function} is closely related to the
denotational semantics of conditionals.

We want to use one of two functions $c$ or $d$ to map some inputs $x$ to
some outputs $y$; and we have a boolean test $b$ for, that will determine
which function to apply in each case $x$.

\begin{center}
cond : $(X \rightarrow T) \times (X \pfun Y) \times (X \pfun Y)
\rightarrow (X \pfun Y)$
\end{center}

We give in three functions, and we get out a function that takes $X$ to
$Y$. We can rewrite this as:

\begin{align*}
    \text{cond}(b,c,d)x = \Bigg \{
        \begin{split}
            c(x) \quad &\text{if } b(x) = tt \\
            d(x) \quad &\text{otherwise}
        \end{split}
\end{align*}

Where $b, c, d$ correspond to the functions we supply. We will be
interested when $X$ and $Y$ are both states. So:

\begin{align*}
    \text{cond} : (\text{State } \rightarrow T) \times (\text{State }
    \pfun \text{ State}) \times (\text{State }
    \pfun \text{ State})\times (\text{State }
    \pfun \text{ State})
\end{align*}

\subsection{Least fixpoint}%
\label{sub:least-fixpoint}
The idea of the \textbf{least fixpoint} of a function is actually quite
heavily studied in maths (particularly in lambda calculus).

There are also a lot of heavy duty theorems, but we'll be using this one:
\textbf{Definition:} For any unary operator $f : X \rightarrow X$ on some
domain $X$ with a partial order $\le:$
% TODO resume from 21:52

% This is the lecture from 4/11/19 and 8/11/19, so please catch up daddio x
\section{Chain-Complete Partial Orders}%
\label{sec:ccpo}
% TODO this lecture

Sets can have upper and lower bounds depending on where they come in the
order of chains. For example, those at the top of the set are the upper
bound of every element since they are unable to have an upper bound
themselves, while the ones at the bottom are the lower bound, since they
have no lower bound themselves.

\subsection{Definitions of PO-Set (partially ordered set)}%
\label{sub:Definitions of PO-Set}
A PO-Set (D, $\sqsubseteq$) is called a \textit{chain-complete} partially
ordered set (ccpo) whenever the least upper bound $\sqcup y$ exists for
all \underline{chains} $Y \subseteq D$.
\begin{itemize}
    \item To be a CCPO, each chain must have an upper bound
\end{itemize}

Furthermore, a PO-Set (D, $\sqsubseteq$) is called a \textit{complete
lattice} whenever the least upper bound $\sqcup Y$ exists for all
\underline{subsets} $Y\subseteq D$.
\begin{itemize}
    \item To be a lattice, each chain must have a ** %TODO
\end{itemize}

Note that every CCPO (D, $\sqsubseteq$) has a (necessarily unique) element
denoted $\bot = \sqcup \ \emptyset$. This means that it is given by the
lease upper bound of the empty chain. First observe $\emptyset$ is a
chain, since we know that $\emptyset \subseteq D$ by the basic set
properties and $d \sqsubseteq e$ vacuously holds for all $d,e \in
\emptyset$ (of which there are none). So, the least upper bound $\bot$ **
%TODO

The question is: is our relation a chain-complete partial order (from the
slides)? The answer, simply, is no.
\begin{itemize}
    \item This is because we have a whole bunch of items at the end. There
        is no least element of the ordering, so it cannot be a CCPO (this
        is an important part of the CCPO).
\end{itemize}

What we can do is the \textbf{lifted} relation, which we obtain by adding
a least element $\bot$. But, does this now make it a CCPO? Yeah, it does.
Nice. HOWEVER, it does not make it a \textbf{complete lattice}.

% lecture from 15/11/19
\section{The language Exc}%
\label{sec:exc-language}
Exc is an extension of the \textbf{while} language whose statements are
defined like as follows. Exc stands for extension:

\begin{align*}
    S ::= x := a | \text{ skip } | \text{ if }b\text{ then } S_1 \text{
    else } S_2 | \text{ while } b \text{ do } S | \text{ begin } S_1
    \text{ handle } e : S_2 \text{ end } | \text{ raise } e
\end{align*}

The idea is that whenever a {\color{green} \textit{raise}} exception
instruction is encountered, then the execution of the current
(encapsulating blocks of) code (such as {\color{blue} $S_1$}) is aborted
and control is passed to the (most recently defined) handler (such as
{\color{blue} $S_2$}) for the exception ({\color{blue} $e$}).

Consider the following \textbf{Exc} statement.
\begin{lstlisting}
begin
    while true do
        if x <= 0
        then raise exit
        else x := x-1
    hand exit:
        y:=7
end
\end{lstlisting}

If this program is run when $x$ is negative then it will terminate after
setting $y$ to 7 (leaving $x$ unchanged).

The meaning of an exception needs to caputer the rsult of executing hte
relevant handler and following by any remaining code after the definition
of that handler.

But this requires a more complicated semantic definition which allows, for
example, for the fact that (differently from the \textit{while} language)
we don't necesarily have to continue running $S_3$ in the following
program after running either $S_1$ or $S_2$ (if either of them raises an
exception) ** %TODO

\subsection{Continuation-style denotational semantics}%
\label{sub:continuation-style}
We can define the set {\color{red}\textbf{Cont}} of continuations as the
set of all partial functions between states so that
{\color{red}\textbf{Cont}} = {\color{red}State} $\pfun$ {\color{red}State}

Intuitively, a continuation is simply a state transformer that describes
the input-output behaviour of a (part of) program.

This concept allows us to define the behaviour o a statement  by the
effect that it has ($c'$) on a continuation defining the behaviour of the
code following that statement ($c$).

Recall the \textbf{direct style denotational semantics}
(\ref{sec:denotational-semantics}). Continuation style denotational
semantics are as follows:
\begin{alignat*}{2}
    &S'_{cs} : {\color{green}\textbf{ Stm }} \rightarrow (
    {\color{red}\textbf{Cont }} &&\rightarrow {\color{red}\textbf{ Cont}}) \\
    &S'_{cs} [\![x:=a]\!]c s &&= c s [x \mapsto \mathcal{A}[\![a]\!]s] \\
    &S'_{cs} [\![ {\color{blue}\textbf{skip}}]\!] &&=
    {\color{blue}\textbf{id}} \\
    &S'_{cs}[\![ {\color{green}S_1}; {\color{green}S_2} ]] &&= S'_{cs}[\![
    {\color{green}S_1} ]\!] ^ {\color{blue}o} S'_{cs} [\![
    {\color{green}S_2} ]\!] \\
    % if then else
    % while do
    % TODO
\end{alignat*}

\end{document}
